# Лабораторная работа 02: Обратная польская запись

[RU|[EN](README.md)]

Эта лабораторная работа предназначена для освоения создания грамматик микро-языков и реализации нескольких семантических действий для одной грамматики.

## Цель

Вам нужно реализовать калькулятор, который поддерживает сложение и умножение, записанные в [обратной польской записи][RPN] (RPN).
"Обычные" арифметические выражения, реализованные в [предыдущей работе](../lab01/README.ru.md), используют *инфиксную* форму записи, в которой знак операции размещается *между* операндами. Обратная польская запись размещает знак операции *после* операндов, то есть использует *постфиксную* нотацию.

Не путайте ее с *прямой* польской записью, где знак операции размещается *перед* операндами.

Грамматика RPN-выражений описывается следующей РБНФ:

```EBNF
rpnExpr = 
    number
  | rpnExpr rpnExpr "+" 
  | rpnExpr rpnExpr "*" 

number = digit { digit } ;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
```

Обратите внимание на то, что эта грамматика не нуждается в скобках или правилах приоритета: порядок операций однозначно определяется размещением аргументов и знаков операций. Эта нотация легко применима для записи программ стековой исполняющей машины, так как каждая операция напрямую отображается в последовательность "положить аргумент 1 на стек; положить аргумент 2 на стек; выполнить операцию". При выполнении операция снимает оба операнда со стека и помещает обратно результат. Максимальная глубина стека вычислений является важным свойством RPN-выражения, так как она напрямую влияет на производительность вычислений.

## Задания

1. Разработайте PEG-грамматику для арифметических выражений, описанных вышеуказанной РБНФ, используя синтаксис библиотеки Ohm. Пустой шаблон грамматики приведен в файле [rpn.ohm](src/rpn.ohm). Заполните его необходимыми правилами.
2. Реализуйте и экспортируйте из файла [index.ts](src/index.ts) композитную функцию `evaluate(content: string): number` со свойствами, сходными со свойствами аналогичной функции из [предыдущей работы](../lab01/README.ru.md).
3. Реализуйте и экспортируйте из файла [index.ts](src/index.ts) функцию `maxStackDepth(content: string): number`, которая возвращает макисмальную глубину стека, необходимого для вычисления заданного RPN-выражения, если оно корректно, или выбрасывает `SyntaxError`, если заданная строка не является корректным RPN-выражением.

## Оценка

- C | 3 | Воу, воу, полегче:
  - Реализовать синтаксический разбор RPN-выражений и вычисление их результата
  - Корректно обработать ошибки разбора
- B | 4 | Ломай меня полностью:
  - Реализовать вычисление максимальной глубины стека

## Советы

1. Определение максимальной глубины стека выражения можно реализовать так же, как и вычисление его значения - как отдельное семантическое действие для грамматики RPN.
2. Для вычисления глубины стека потребуется как максимальная глубина стека при вычислении аргумента, так и глубина остатка стека после окончания этого вычисления. Это можно обеспечить путем реализации *двух* семантических действий или атрибутов, или как одно действие, возвращающее значение композитного типа ([интерфейс][interface] или [кортеж][tuple].

[RPN]: https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C
[interface]: https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces
[tuple]: https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types
