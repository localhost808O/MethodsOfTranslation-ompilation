# Язык Funny

[RU|[EN](funny.md)]

Funny позволяет пользователю описывать *модули*. Модуль состоит из именованных [*функций*](#функции-и-типы) и [*формул*](#определения-формул).

Этот модуль компилируется в модуль WebAssembly.

Некоторые исходные тексты Funny можно найти в [образцах для лабораторной работы 08](./lab08/samples/) и [лабораторной работы 10](./lab10/samples/).

## Предыстория и обоснование Funny

Язык Funny был разработан для весьма конкретной цели: быть игрушечным языком для обучения компиляции и верификации.
Перед языком были поставлены следующие основные цели:

1. Простота синтаксического разбора
2. Простота компиляции в Wasm
3. Достаточная сложность для демонстрации особенностей верификации императивных программ

Цель № 1 повлияла на выбор ключевых слов и общего синтаксиса: грамматика не содержит двусмысленностей на уровне определений и операторов.

Цель № 2 привела к отказу от операторов goto и поддержки затейливых типов данных.

Цель № 3 побудила нас:

- поддерживать несколько возвращаемых значений у функций (что также оказалось хорошо совместимым с целью № 2)
- сделать параметры функций неизменяемыми
- упорядочить разделы объявления функции так, чтобы гарантировать очевидность областей действия всех переменных
- поддерживать формулы в дополнение к функциям

Все эти микрорешения помогают пользователю писать аннотации функций.

## Основы языка

Грамматика Funny не зависит от невидимых символов, т. е. любое количество последовательных пробелов, табуляции и новых строк имеет ту же семантику, что и один пробел. В грамматиках ниже пробелы разрешены между любыми правилами (включая терминалы) в операции конкатенации. Например, грамматике `"if" "("` соответствует как `"if ("`, так и `"if("`.

Комментарии в Funny начинаются с двойной косой черты (`//`) и заканчиваются новой строкой (`\r` или `\n`). Комментарии также считаются пробелами, т. е. они разделяют лексическую единицу, но в остальном не влияют на смысл программы.

### Константы

Funny поддерживает константы типа `int`, записанные в виде последовательностей цифр, и логические константы `true` и `false`.

### Идентификаторы

Идентификаторы в Funny начинаются с латинской буквы и могут содержать произвольное количество букв и цифр. Никаких замысловатостей вроде подчеркиваний, verbatim-идентификаторов или национальных алфавитов не допускается ради простоты синтаксического анализатора.

### Исключения

Функция Funny может выбрасывать несколько исключений:

- деление на ноль приводит к выбросу исключения
- доступ к массиву приводит к выбросу исключения

Поскольку в Funny нет средств *обработки* исключений, эти исключения могут быть перехвачены только во внешнем коде, вызывающем модуль Funny.

## Функции и типы

Все функции, определенные в модуле Funny, автоматически экспортируются.

Синтаксис определения функции следующий:

```EBNF
function = identifier                          (* имя функции *)
    "(" [ variableDef {"," variableDef } ] ")" (* параметр(ы) функции *)
    ["requires" predicate ]                    (* предусловие функции *)
    "returns" variableDef {"," variableDef }   (* возвращаемое(ые) значение(я) функции *)
    ["ensures" predicate ]                     (* постусловие функции *)
    [ "uses" variableDef {"," variableDef } ]  (* локальная(ые) переменная(ые) функции *)
    statement;                                 (* тело функции *)

variableDef =
    identifier (* имя переменной*)
    ":" variableType;

variableType = "int" | "int[]";
```

Каждая функция имеет ноль или более входных параметров и один или более выходных параметров.

Funny поддерживает два типа данных для входов и выходов:

- `int` означает 32-битное знаковое (в дополненном до 2 виде) целое число
- `int[]` означает массив `int`

Функция может объявлять локальные переменные.
Локальные переменные могут быть только типа `int`.

Имена входных параметров функции, выходных параметров и локальных переменных должны быть уникальными в пределах функции.

Функции могут вызывать другие функции, включая прямую и косвенную рекурсию.

Имена функций должны быть уникальными в пределах модуля; перегрузки не допускаются.

Следующая функция принимает два целых числа и возвращает два целых числа:

```funny
divide(a: int, b: int)
returns q: int, r: int
...
```

Следующая функция принимает два целых числа, возвращает одно целое число и использует две локальные переменные:

```funny
gcd(x: int, y: int)
returns r: int
uses a: int, b: int // объявления локальных переменных
```

Предусловие функции может использовать только параметры функции. Если оно опущено, предполагается, что предусловие равно `true`, т. е. выполнено для всех значений аргументов. Подробнее о синтаксисе предикатов см. в разделе [Предикаты](#предикаты).

Постусловие функции может использовать параметры функции и возвращаемые значения. Если оно опущено, то предполагается, что постусловие равно `false`, т. е. никогда не выполняется.

> Хотя и заманчиво потребовать указания постусловия для каждой функции прямо в синтаксисе, такой подход оказывается контрпродуктивным.
>
> Принудительное использование более строгого синтаксиса обеспечивает (в лучшем случае) незначительное упрощение фазы семантического анализа, но приводит к существенному ухудшению условий работы для конечного пользователя.
>
> В целом, синтаксические ошибки блокируют процесс анализа; поэтому простой синтаксический анализатор никогда не выдаст больше одной синтаксической ошибки.
Семантические ошибки, с другой стороны, не обязательно блокируют процесс проверки, поэтому компилятор может обнаружить и описать несколько проблем за один проход.
Это настолько удобнее для конечного пользователя, что реальные синтаксические анализаторы зачастую намеренно проектируются с использованием существенно расширенного синтаксиса по сравнению с официальной спецификацией языка. Хотя обсуждение общих подходов к *восстановлению синтаксического разбора после обнаружения ошибок* выходит далеко за рамки этого курса, стоит упомянуть об нем в этом маленьком примере.

## Определения формул

Формула — это особый вид функции, которая должна использоваться в предикатах. Они никогда не компилируются в код Wasm и используются только в статической верификации:

```EBNF
formula = identifier                            (* название формулы *)
    "(" [ variableDef {"," variableDef  } ] ")" (* параметр(ы) формулы *)
    "=>" predicate;                             (* тело формулы *)
```

## Операторы

В Funny есть четыре типа операторов:

```EBNF
statement = assignment | conditional | loop | block;
```

### Оператор присваивания

Оператор присваивания имеет следующую форму:

```EBNF
assignment = 
    varName "=" expr ";"                           (* простое присваивание *)
    | arrayAccess "=" expr ";"                     (* изменение элемента массива *)
    | varName { "," varName } "=" functionCall ";" (* присваивание кортежа *)
```

Последняя форма представляет собой присваивание кортежа; она применяется к функциям, возвращающим несколько результатов. Подробнее см. в подразделе [Вызов функции](#вызов-функции) ниже.

Обратите внимание, что параметры функции считаются доступными только для чтения — их нельзя использовать в левой части оператора присваивания. Это касается и массивов — массив, переданный в качестве параметра, нельзя использовать в левой части оператора присваивания.

И локальные переменные, и выходные параметры считаются доступными для чтения и записи.
Чтение до первого присваиванием не является ошибкой, но содержимое неинициализированных переменных не определено.

### Условный оператор

Условный оператор имеет следующую форму:

```EBNF
conditional = "if" "(" condition ")" statement ["else" statement];
```

Вложенные условные операторы являются правоассоциативными. Здесь `else` принадлежит второму `if`:

```funny
if (x > 0) if (y < 0) z = 1; else z = 5;
// эквивалентно этому:
if (x > 0)
{
    if (y < 0)
    z = 1;
    else z = 5;
}
// НЕ этому:
if (x > 0)
{
    if (y < 0)
    z = 1;
}
else
    z = 5; 
```

### Оператор цикла

Оператор цикла имеет следующую форму:

```EBNF
while = "while" "(" condition ")"
    [ "invariant" predicate ]
    statement;
```

Если инвариант цикла опущен, то он считается равным `true`. Этот раздел оператора цикла намеренно сделан необязательным по тем же причинам, как и пред- и пост-условия [функций](#функции-и-типы).

### Блочный оператор

Блочный оператор позволяет группировать несколько операторов вместе:

```EBNF
block = "{" { statement } "}";
```

Обратите внимание, что точка с запятой не является "разделителем операторов" - это часть оператора присваивания.

## Выражения

Выражения Funny в основном такие же, как в [лабораторной работе 03](./lab03/README.ru.md), с двумя дополнительными атомами:

```EBNF
expr =
    functionCall (* вызов функции *)
  | arrayAccess  (* обращение к элементу массива*)
  (* далее описано такое же арифметическое выражение, как и в лабораторной 03: *)
  | number
  | variable
  | "-" expr
  | expr "+" expr
  | expr "*" expr
  | expr "-" expr
  | expr "/" expr
  | "(" expr ")";
```

### Вызов функции

Выражение вызова функции использует позиционные аргументы:

```EBNF
functionCall = identifier   (* имя функции *)
"(" [ expr {"," expr} ] ")" (* аргументы функции *)
```

**Обратите внимание**, что в выражениях можно использовать только функции с одним возвращаемым значением; функция, возвращающая несколько результатов, может быть либо вызвана из внешнего кода либо использована в [присвоении кортежа](#оператор-присваивания).

Типы и количество выражений в списке аргументов функции должны соответствовать типам и количеству параметров функции. Имя функции должно ссылаться на существующую функцию, определенную в модуле, или на встроенную функцию [`length`](#функция-length).

#### Функция length

Встроенная функция `length` возвращает длину массива. Он ведет себя так, как будто объявлена со следующей сигнатурой:

```funny
length(a: int[]) returns l: int
```

### Обращение к элементу массива

Операция обращения к массиву позволяет читать значение элемента массива:

```EBNF
arrayAccess = varName "[" expr "]"
```

Переменная, на которую ссылается varName, должна иметь тип массива; выражение, используемое в индексе, должно иметь целочисленный тип.
Доступ к массиву за пределами границ массива вызывает исключение во время выполнения.

## Условия

Условные операторы и операторы while используют конструкции *условий*.
Эти конструкции представляют *логические выражения*, построенные из выражений сравнения и констант `true`/`false` с помощью операций конъюнкции, дизъюнкции и отрицания:

```EBNF
condition = 
  "true" | "false"
  | comparison
  | "not" condition
  | condition "and" condition
  | condition "or" condition
  | condition "->" condition
  | "(" condition ")";

comparison = 
  expr "==" expr
  | expr "!=" expr
  | expr ">=" expr
  | expr "<=" expr
  | expr ">" expr
  | expr "<" expr;
```

## Предикаты

Предикаты в Funny похожи на [условия](#условия).
Это также булевы формулы, но атомы предикатов допускают две дополнительные конструкции - [*кванторы*](#кванторы) и [*ссылки на формулы*](#ссылки-на-формулы):

```EBNF
predicate = 
  quantifier
  | formulaRef
(* эта часть похожа на условие *)
  | "true" | "false"
  | comparison
  | "not" predicate
  | predicate "and" predicate
  | predicate "or" predicate
  | "(" predicate ")";

```

### Кванторы

Конструкция квантора позволяет объявлять кванторы существования и всеобщности в предикатах.

```EBNF
quantifier = ("forall" | "exists") (* тип квантора *)
    "(" variableDef                (* переменная предиката *)
        "|" predicate              (* предикат *)
    ")";
```

**Обратите внимание**, что имя переменной, объявленное в кванторе, должно быть уникальным в области действия, содержащей квантор:

- область действия предусловия функции содержит все параметры функции
- область действия постусловия функции содержит все параметры и возвращаемые значения функции
- область действия инварианта цикла содержит все параметры, возвращаемые значения и локальные переменные функции

### Ссылки на формулы

Ссылки на формулы ведут себя аналогично вызовам функций, но используются только в предикатах. Ссылки на формулы нельзя использовать ни в условиях, ни в выражениях.

```EBNF
formulaRef = identifier         (* имя формулы *)
    "(" [ expr {"," expr} ] ")" (* аргументы формулы *)
```

Ссылка на формулу должна ссылаться на существующее [определение формулы](#определения-формул).
