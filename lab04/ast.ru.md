# Построение AST на языке Typescript

[RU|[EN](./ast.md)]

Важным свойством абстрактных синтаксических деревьев является *гетерогенность* - т.е. узлы дерева могут быть разных типов (хотя они могут иметь некоторые общие свойства или поведение).

Различные языки программирования предлагают разные концепции, которые можно использовать для описания узлов AST.

На **объектно-ориентированных** языказ типы узлов AST обычно описываются при помощи иерархии классов с одним или несколькими корнями.
Этот подход предлагает наиболее легкий способ расширения набора типов - например, если мы хотим добавить тип узла `Переменная` к нашему типу `Выражение`, мы можем просто отнаследовать его соответствующим образом:

```ts
class Variable extends Expr {
//    ...
}
```

Однако, ценой этого является отсутствие поддержки компилятора в проверке полноты, когда мы реализуем некоторое *внешнее поведение*.

На **функциональных** языках подобные иерархии описываются *алгебраическими типами*. Добавление новых членов в такие типы может вызывать затруднения, но взамен мы получаем улучшенный контроль за полнотой кода обхода деревьев.

## Внешнее поведение

Термин, упомянутый выше, обозначает типовой шаблон реализации, который отделяет поведение от данных. На первый взгляд, это противоречиит идиоме ООП, но даже в ООП этот шаблон время от времени приходится использовать.

Рассмотрим иерархию классов, которая описывает животных. У нас будет абстрактный базовый класс `Animal` и два конкретных потомка: `Cat` и `Dog`. Абстрактность здесь означает, что у нас есть некоторое *общее поведение*, которое может быть реализовано *различным образом*  в каждом из классов. Например, экземплярный метод `voice()`, который будет возвращать `'bark'` у экземпляров `Dog` и `'meow'` в классе `Cat`.
Что, если *впоследствии* в процесс разработки перед нами встает необходимость, скажем, выводить *вид животного*. Мы могли бы вернуться на фазу дизайна, добавить в базовый класс новый виртуальный метод `kind()`, и реализовать его в каждом из потомков. Однако, это может оказаться невозможным (иерархия классов фиксирована и пришла к нам из внешнего источника) или непрактичным (описания типов в нашей власти, но мы не хотим засорять определения типов дополнительным поведением, которое не является их неотъемлемой характеристикой). Это не является "естественным" поведением сущностей, представленных классом `Animal`; это некоторое "внешнее" поведение, которое мы хотим *присоединить* к нашему типу.

Решение, которое предлагает ООП для этой проблемы, называется [шаблоном "Посетитель"][visitor]:

```ts
abstract class Visitor<T>
{
    visit(a: Animal) : T { return a.visit(this);}
    abstract visitDog(d: Dog): T;
    abstract visitCat(c: Cat): T; 
}

abstract class Animal
{
    abstract voice(): string;
    abstract visit<T>(visitor: Visitor<T>): T
}

class Dog extends Animal
{
    voice = ()=> 'bark';
    visit<T>(visitor: Visitor<T>) { return visitor.visitDog(this);}
}
class Cat extends Animal
{
    voice = ()=> 'meow';
    visit<T>(visitor: Visitor<T>) { return visitor.visitCat(this);}
}

class KindVisitor extends Visitor<string>
{
    visitDog = (d: Dog) => 'dog' ;
    visitCat = (c: Cat) => 'cat';    
}
```

Это вполне приемлемый (хотя и несколько многословный) способ решения *в случае, если иерархия классов "запечатана"*, то есть нет способов добавить новый класс в эту иерархию. Иначе предположения, сделанные при дизайне класса `Visitor` будут нарушены, следовательно, заложенная в него логика обработки станет некорректной.

Функциональное программирование даже не пытается связывать данные с поведением. В нем тип `Animal` будет алгебраической суммой типов `Dog` и `Cat`. И как `voice`, так и `kind` будут *функциями*, принимающими единственный аргумент типа `Animal`. Разработчик, реализующий эти функции, должен явно обработать каждый из термов, входящих в тип  `Animal` - т.е. предоставить логику для возврата значений `voice` и `kind` для экземпляров `Cat` и `Dog`.

Хорошая новость состоит в том, что компиляторы большинства статически типизированных функциональных языков реализуют так называемую проверку полноты, статически верифицируя наличие обработки для каждого из подтипов:

```ts

interface Dog{
    type: 'Dog';
};
interface Cat{
    type: 'Cat';
};

type Animal = Dog | Cat;

function voice(a: Animal): string
{
    switch(a.type)
    {
        case 'Dog': return 'bark';
        case 'Cat': return 'meow';
    }
}

function kind(a: Animal): string // ts 2366: `Function lacks ending return statement and return type does not include 'undefined'`
{
    switch(a.type)
    {
        case 'Dog': return 'dog';
        //case 'Cat': return 'cat'; // uncomment this line to avoid compile-time error
    }
}

```

Система типов Typescript достаточно развита для того, чтобы поддерживать оба подхода, так что окончательный выбор остается за пользователем.

## ООП в Typescript

Typescript поддерживает понятие [классов][classes] с одиночным наследованием. Детали можно посмотреть в документации. Реализовывать ли генерацию кода для узлов AST при помощи виртуального метода, или вне узлов при помощи паттерна Посетитель остаётся на усмотрение студента.

## Алгебраические типы в Typescript

Применение алгебраических типов для построения AST относительно прямолинейно. Каждый из видов узлов можно естественным образом описать при помощи интерфейсного типа со специфичными для данного вида атрибутами.

Например, крайне упрощенная грамматика арифметических выражений может соответствовать AST, описанному при помощи следующих типов:

```ts
type Expr = Const | Negation;
interface Const 
{
    type: 'const',
    value: number
}
interface Negation
{
    type: 'neg',
    argument: Expr;
}
```

Обратите внимание на дискриминирующий атрибут `type`, помогающий нам отличать друг от друга экземпляры `Const` и `Number`. Он поможет нам опираться на сужение типов, реализованное в компиляторе Typescript.

Частными случаями сужения типов являются [сопоставление с образцом][pattern-matching] и проверка полноты.
Например, вычисление значения выражения, описанного при помощи типа `Expr`, определенного выше, может выглядеть так:

```ts
calc(e: Expr): number
{
    switch(e.type)
    {
        case 'const': return e.value; // e here is of type Const
        case 'neg': return - calc(e.argument) // e here is of type Neg
    }
}
```

[visitor]: https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%B5%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
[classes]: https://www.typescriptlang.org/docs/handbook/2/classes.html
[pattern-matching]: https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D1%86%D0%BE%D0%BC
